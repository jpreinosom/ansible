- name: Leer y procesar el inventario CSV
  hosts: localhost  # Ejecutamos en localhost para procesar los archivos
  gather_facts: no
  vars:
    input_file: "{{ playbook_dir }}/inventory/webServer.csv"
    delimiter: ";"
  tasks:
    - name: Verificar que el archivo CSV existe
      stat:
        path: "{{ input_file }}"
      register: file_check

    - name: Fallar si el archivo de inventario no existe
      fail:
        msg: "El archivo de inventario {{ input_file }} no existe."
      when: not file_check.stat.exists

    - name: Leer contenido del archivo CSV
      set_fact:
        csv_content: "{{ lookup('file', input_file) }}"

    - name: Extraer encabezados del CSV
      set_fact:
        headers: "{{ csv_content.split('\n') | first | split(delimiter) | map('trim') | list }}"

    - name: Extraer filas del CSV
      set_fact:
        rows: "{{ csv_content.split('\n')[1:] | reject('match', '^$') | list | map('split', delimiter) | list }}"

    - name: Validar que cada fila tenga el mismo número de campos que los encabezados
      fail:
        msg: "La fila {{ row }} no tiene el mismo número de campos que los encabezados."
      when: row | length != headers | length
      loop: "{{ rows }}"
      loop_control:
        loop_var: row

    - name: Combinar encabezados con filas para crear diccionarios
      set_fact:
        csv_data: "{{ csv_data | default([]) + [ dict(headers | zip(row)) ] }}"
      loop: "{{ rows }}"
      loop_control:
        loop_var: row

    - name: Verificar contenido de csv_data
      debug:
        msg: "{{ csv_data }}"  # Mostrar el contenido de csv_data para asegurarse de que tiene las claves correctas

- name: Ejecutar comandos e información por cada servidor
  hosts: localhost
  gather_facts: yes
  vars_files:
    - vars/eol_map.yml
    - vars/release_map.yml
  tasks:
    - name: Verificar que csv_data tiene las claves correctas
      debug:
        msg: "Clave IP: {{ item.IP }}, Clave Usuario: {{ item.Usuario }}"
      loop: "{{ csv_data }}"
      when: item.IP is defined and item.Usuario is defined

    - name: Obtener información de cada servidor remoto
      ansible.builtin.command:
        cmd: "ssh -i ~/.ssh/id_rsa {{ item.Usuario }}@{{ item.IP }} uname -a"
      loop: "{{ csv_data }}"
      register: command_results
      delegate_to: local

    - name: Obtener la familia del sistema operativo por nodo
      ansible.builtin.command:
        cmd: "ssh -i ~/.ssh/id_rsa {{ item.Usuario }}@{{ item.IP }} cat /etc/os-release | grep ^ID="
      loop: "{{ csv_data }}"
      register: os_family_result
      loop_control:
        loop_var: item
      when: item.IP is defined

    - name: Obtener la versión de la distribución por nodo
      ansible.builtin.command:
        cmd: "ssh -i ~/.ssh/id_rsa {{ item.Usuario }}@{{ item.IP }} lsb_release -d"
      loop: "{{ csv_data }}"
      register: distribution_version_result
      loop_control:
        loop_var: item
      when: item.IP is defined

    - name: Obtener la fecha actual del sistema por nodo
      set_fact:
        current_date: "{{ ansible_date_time.date | regex_replace('-', '') }}"  # YYYYMMDD
      loop: "{{ csv_data }}"
      loop_control:
        loop_var: item
      when: item.IP is defined

    - name: Determinar la fecha de EoL para la distribución y versión por nodo
      ansible.builtin.command:
        cmd: "ssh -i ~/.ssh/id_rsa {{ item.Usuario }}@{{ item.IP }} cat /etc/os-release | grep ^VERSION_ID="
      loop: "{{ csv_data }}"
      register: eol_date_result
      loop_control:
        loop_var: item
      when: item.IP is defined

    - name: Obtener fecha de lanzamiento para la distribución y versión por nodo
      ansible.builtin.command:
        cmd: "ssh -i ~/.ssh/id_rsa {{ item.Usuario }}@{{ item.IP }} cat /etc/os-release | grep ^VERSION="
      loop: "{{ csv_data }}"
      register: release_date_result
      loop_control:
        loop_var: item
      when: item.IP is defined

    - name: Obtener el estado de suscripción en RedHat por nodo
      ansible.builtin.command:
        cmd: "ssh -i ~/.ssh/id_rsa {{ item.Usuario }}@{{ item.IP }} subscription-manager status"
      register: subscription_status_output
      when: ansible_distribution in ["RedHat"]
      ignore_errors: yes
      loop: "{{ csv_data }}"
      loop_control:
        loop_var: item

    - name: Establecer el estado de suscripción por nodo
      set_fact:
        subscription_status: >-
          {% if 'Overall Status: Current' in subscription_status_output.stdout %}
            Suscrita
          {% else %}
            No Suscrita
          {% endif %}
      loop: "{{ subscription_status_output.results }}"
      loop_control:
        loop_var: item
      when: ansible_distribution in ["RedHat"]

    - name: Obtener nombre de la máquina (FQDN) por nodo
      ansible.builtin.command:
        cmd: "ssh -i ~/.ssh/id_rsa {{ item.Usuario }}@{{ item.IP }} hostname -f"
      loop: "{{ csv_data }}"
      register: fqdn_result
      loop_control:
        loop_var: item
      when: item.IP is defined
      ignore_errors: yes
    - name: Guardar los datos en una lista por nodo
      set_fact:
        server_data: "{{ server_data | default([]) + [{
          'IP': item.IP,
          'distribucion': os_family_result.stdout | default('No disponible'),
          'version': distribution_version_result.stdout | default('No disponible'),
          'familia': os_family_result.stdout | default('No disponible'),
          'soportada': subscription_status,
          'eol': eol_date_result.stdout | default('No definido'),
          'release': release_date_result.stdout | default('No definido'),
          'nombre': fqdn_result,
          'suscrita': subscription_status
        }] }}"
      loop: "{{ csv_data }}"
      loop_control:
        loop_var: item

    - name: Mostrar los datos recogidos por nodo
      debug:
        msg: "{{ server_data }}"

        # Generar el archivo SQL para insertar scores
    - name: Generar archivo SQL para inserciones de score
      copy:
        dest: /tmp/insert_inventario.sql
        content: |
          {% for sc in server_data %}
          INSERT INTO inventario (ip, distribucion, version, familia, soportada, eol, release, nombre, suscrita)  VALUES ('{{ sc.IP }}', '{{ sc.distribucion }}', '{{ sc.version }}' ,'{{ sc.familia }}','{{ sc.soportada }}','{{ sc.eol }}','{{ sc.release }}','{{ sc.nombre }}','{{ sc.suscrita }}');
          {% endfor %}
      when: server_data is defined and server_data | length > 0
      delegate_to: local
     # >>> Nuevo <<<: Recolectar scores de cada host (solo necesitamos un score por host)
- name: Insertar registros en la tabla inventario en la base de datos
  hosts: localhost  # Ejecutamos en localhost porque estamos procesando los datos de csv_data
  gather_facts: no
  vars:
    grafana_file: "{{ playbook_dir }}/inventory/grafana.csv"
    delimiter: ";"
    vulnerability_password: "grafana_password"
  tasks:
    - name: Verificar que el archivo Grafana CSV existe
      stat:
        path: "{{ grafana_file }}"
      register: grafana_file_check

    - name: Fallar si el archivo de inventario Grafana no existe
      fail:
        msg: "El archivo de inventario {{ grafana_file }} no existe."
      when: not grafana_file_check.stat.exists

    - name: Leer contenido del archivo Grafana CSV
      set_fact:
        grafana_csv_content: "{{ lookup('file', grafana_file) }}"

    - name: Extraer encabezados del archivo Grafana CSV
      set_fact:
        grafana_headers: "{{ grafana_csv_content.split('\n') | first | split(delimiter) | map('trim') | list }}"

    - name: Extraer filas del archivo Grafana CSV
      set_fact:
        grafana_rows: "{{ grafana_csv_content.split('\n')[1:] | reject('match', '^$') | list | map('split', delimiter) | list }}"

    - name: Validar que cada fila del archivo Grafana tenga el mismo número de campos que los encabezados
      fail:
        msg: "La fila {{ row }} no tiene el mismo número de campos que los encabezados."
      when: row | length != grafana_headers | length
      loop: "{{ grafana_rows }}"
      loop_control:
        loop_var: row

    - name: Combinar encabezados con filas del archivo Grafana para crear diccionarios
      set_fact:
        grafana_csv_data: "{{ grafana_csv_data | default([]) + [ dict(grafana_headers | zip(row)) ] }}"
      loop: "{{ grafana_rows }}"
      loop_control:
        loop_var: row

    - name: Acceder a un valor específico de grafana_csv_data (por ejemplo, IP y Usuario)
      debug:
        msg: "IP: {{ grafana_csv_data[0]['IP'] }}, Usuario: {{ grafana_csv_data[0]['Usuario'] }}"

    - name: copiar archivo SQL para inventario
      command: >
        scp /tmp/insert_inventario.sql {{ grafana_csv_data[0]['Usuario'] }}@{{ grafana_csv_data[0]['IP'] }}:/home/grafana/
      when: server_data is defined and server_data | length > 0
      delegate_to: local


    - name: Ejecutar archivo SQL para inventario
      command: >
        ssh -i ~/.ssh/id_rsa {{ grafana_csv_data[0]['Usuario'] }}@{{ grafana_csv_data[0]['IP'] }} "env PGPASSWORD={{ vulnerability_password }} psql -U grafana_user -d grafana_db -f /home/grafana/insert_inventario.sql"
      when: server_data is defined and server_data | length > 0
      delegate_to: local

    - name: eliminar archivo SQL para inventario
      command: >
        ssh -i ~/.ssh/id_rsa {{ grafana_csv_data[0]['Usuario'] }}@{{ grafana_csv_data[0]['IP'] }} rm -rf /home/grafana/insert_inventario.sql
      when: server_data is defined and server_data | length > 0
      delegate_to: local
